package ca.vgorcinschi.qandauser.impl.events

import akka.persistence.query.Offset
import akka.{Done, NotUsed}
import akka.stream.scaladsl.Flow
import ca.vgorcinschi.qandauser.impl.data.Database
import com.lightbend.lagom.scaladsl.persistence.ReadSideProcessor.ReadSideHandler
import com.lightbend.lagom.scaladsl.persistence.{AggregateEventTag, EventStreamElement, ReadSideProcessor}

import scala.concurrent.Future

/**
 * We need to transform the events generated by [[ca.vgorcinschi.qandauser.impl.entities.UserEntity]] entity
 * into database tables that can be queried as illustrated in the previous section.
 * @note this class will consume events produced by persistent entity and update
 *       the database table.
 */
class UserEventProcessor(db: Database) extends ReadSideProcessor[UserEvent]{

  override def buildHandler(): ReadSideProcessor.ReadSideHandler[UserEvent] = {
    new ReadSideHandler[UserEvent] {
      override def globalPrepare(): Future[Done] = db.createTables()

      override def prepare(tag: AggregateEventTag[UserEvent]): Future[Offset] = db.loadOffset(tag)

      override def handle(): Flow[EventStreamElement[UserEvent], Done, NotUsed] = {
        Flow[EventStreamElement[UserEvent]]
          .mapAsync(1){
            eventElement =>
              db.handleEvent(eventElement.event, eventElement.offset)
          }
      }
    }

  }

  // returns all tags that the processor needs to handle
  override def aggregateTags: Set[AggregateEventTag[UserEvent]] = UserEvent.Tag.allTags
}
